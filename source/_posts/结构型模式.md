title: 结构型模式
date: 2014-03-20 11:44:42
tags:
---

--------
## 适配器模式（Adapter Pattern)：
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。    

适配器模式有`类适配器`和`对象适配器`两种不同的类型：    
* 类适配器：通过继承的方式来调用已有的接口来实现转换接口。
![](/imgs/lspq.png)

* 对象适配器：通过对象引用的方式来调用已有的接口来实现接口的转换
![](/imgs/dxspq.png)



----------
## 门面模式（Facade Pattern)：  
1. `实现原理：`它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。也就是将众多的子接口或者子模	块包装一下，让客户更方便地调用。
2. `优点：`
  * 松散耦合：门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
  * 简单易用：门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了.
  * 更好的划分访问层次：通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。
![](/imgs/mmms.png)

  * Facade:这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口
  * Clients:客户对象通过一个外观接口读写子系统中各接口的数据资源。
  * Packages:客户可以通过外观接口读取的内部库。

描述门面模式的例子：
![](/imgs/mmmslz.png)

----------
## 代理模式（Proxy pattern)：
1. `实现原理：`为其他对象提供一种代理以控制对这个对象的访问。
2. `优点：`可以在实际调用的对象和客户端之间添加一些额外的操作。

分为`静态代理`和`动态代理`：
* 静态代理：
>![](/imgs/jtdl.png)
* 动态代理：

----------
## 合成模式（Composite Pattern)：
1. `实现原理：`合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。
2. `优点：`合成模式使得客户端把一个个单独的成分对象和由它们复合而成的合成对象同等看待。
![](/imgs/hcms.png)

---------
## 享元模式（Flyweight Pattern)：
1. `实现原理`：
![](/imgs/xyms.png)
2. `优点`：享元模式以共享的方式高效地支持大量的细粒度对象。它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。



----------
## 装饰着模式（Decorator Pattern)：
1. `实现原理`：是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。
2. `优点`：就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。
![](/imgs/zsz.jpg)



----------
7.桥模式（Bridge Pattern)：
1. `实现原理`：桥模式就是把抽象部分和它的实现部分分离开来，让两者可独立变化。      
  组成：
  * 抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。
  * 修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。
  * 实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。
  * 具体实现化(Concrete Implementor)角色：这个角色给出实现接口的具体实现。
2. 优点：桥模式就是把抽象部分和它的实现部分分离开来，让两者可独立变化。分离就把实现部分从它要实现的抽象部分独立出来，自我封装成对象。
![](/imgs/qjms.jpg)