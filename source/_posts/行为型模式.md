title: 行为型模式
date: 2014-03-20 12:44:43
tags:
- design pattern
---

## 策略模式（Strategy Pattern)
1. `实现原理`：其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替
2. `优点`：将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。
![](/imgs/clms.png)


------
## 迭代器模式（Iterator Pattern)
1. `实现原理`：提供一种方法访问一个容器（container）对象中的各个元素，而又不暴露该对象的内部细节。
2. `优点`：它可以让使用者透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。
![](/imgs/ddqms.png)


-------
## 模板方法模式（Template Method Pattern)
1. `实现原理`：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。这里的算法的结构，可以理解为你根据需求设计出来的业务流程。特定的步骤就是指那些可能在内容上存在变数的环节。
2. `优点`：模板方法模式也是为了巧妙解决变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。
![](/imgs/mbffms.jpg)


-------------
## 中介者模式（Mediator Pattern)
1. `实现原理`：用一个中介者对象来封装一系列的对象交互。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。
2. `优点`：它将各Colleague解耦。Mediator有利于各Colleague间的松耦合，你可以独立的改变和复用各Colleague类和Mediator类。 它简化了对象协议用Mediator和各Colleague间的一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。 
![](/imgs/zjzms.png)




--------
## 访问者模式（Visitor Pattern)
1. `实现原理`：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。（gof）
每一个元素实现visitable接口的accept方法接受一个visitor的实例对象，并且使用这个实例对象的visit方法来把自己的引用传递过去，
![](/imgs/fwz1.png)
而真正调用时在concreteVisitor里面
![](/imgs/fwz2.png)
2. `优点`：
![类图](/imgs/fwzms.png)


----------
## 职责链模式（Chain of Responsibility)
1. `实现原理`：通过给一个以上对象处理请求的机会来避免请求的发送者和接收者的耦合。链接接收对象并在链中传递请求直到有对象处理它。
![](/imgs/zzlms.png)
我的理解：在每一个concreteHandler里面加入另外一个concreteHandler的对象的引用，从而实现处理的传递。
2. `优点`：避免请求的发送者和接收者之间的耦合关系。




--------
## 状态模式（State Pattern)
1. `实现原理`：状态模式的意图是，允许一个对象在其内部状改变时改变它的行为。看起来就像是改变了它的类一样
![](/imgs/ztms.png)
个人理解：这个跟职责链模式有很大的相似之处，职责链模式是他的处理的对象是排成一个链子，并且对象必须要把这个链子走完；但是状态模式的下一个引用就可能没有排成一个链子状，而且很多时候也不需要走完所有的状态，他指示把if else变成类之间的转换。
2. `优点`：主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。







---------
## 解释器模式（Interpreter Pattern)
1. `实现原理`：定义语言的文法，并且建立一个解释器来解释该语言中的句子。它属于类的行为模式。这里的语言意思是使用规定格式和语法的代码。
![](/imgs/jsqms.png)
  * 抽象表达式角色(AbstractExpression): 声明一个抽象的解释操作,这个接口为所有具体表达式角色都要实现的.
  * 终结符表达式角色(TerminalExpression): 实现与文法中的元素相关联的解释操作,通常一个解释器模式中只有一个终结符表达式,但有多个实例对应不同的终结符.
  终结符就是语言中用到的基本元素,一般不能再被分解,如: x -> xa, 这里a是终结符，因为没有别的规则可以把a变成别的符号，不过x可以变成别的符号，所以x是非终结符.
  * 非终结符表达式角色(NonterminalExpression): 文法中的每条规则对应于一个非终结表达式, 非终结表达式根据逻辑的复杂程度而增加,原则上每个文法规则都对应一个非终结符表达式.
  * 环境角色(Context): 包含解释器之外的一些全局信息.
2. `应用环境`：
如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。而且当文法简单、效率不是关键问题的时候效果最好。



--------
## 观察者模式（Observer Pattern）
1. `实现原理`：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也可以只通知部分。（gof）
![](/imgs/gczms.png)
  * `抽象主题(Subject)角色`：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色.
  * `具体主题(ConcreteSubject)角色`：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色.
  * `抽象观察者(Observer)角色`：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口.
  * `具体观察者(ConcreteObserver)角色`：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用.
在观察者模式中，又分为`推模型`和`拉模型`两种方式。
  * 推模型:主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据.
  * 拉模型:主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
2. `优点`：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。






-----------
## 命令模式（Command Pattern)
1. `实现原理`：
![](/imgs/mlms.png)
命令模式涉及到五个角色，它们分别是：
 * 客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。
 * 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。
 * 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。
 * 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。
 * 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。
2. `优点`：用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。分离变化与不变的因素。